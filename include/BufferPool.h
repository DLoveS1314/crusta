#ifndef _BufferPool_H_#define _BufferPool_H_#include <basics.h>BEGIN_CRUSTA/**    Interface for allocators creating and destroying buffers for pools.*/class BufferPoolAllocator{public:    virtual void* allocate(uint size) = 0;    virtual void  deallocate() = 0;};/**    A server offering "raw" memory chunks.    The pool is instructed as to what sized memory buffer to offer. Requests    for buffers are then serviced by returning a buffer of the smallest managed    size that suffices the request.*/class COREDLL BufferPool{protected:    /** type for a pool index */    typedef uint indexType;public:    /** pool descriptor */    struct PoolDesc {        /** size of the buffers to allocate */        uint size;    };    /** an array of pool descriptors (for initialization) */    typedef mgi_vector<PoolDesc> PoolDescVec;    /** a handle to a specific pool */    class COREDLL Index {        friend class BufferPool;    protected:        /** the biggest valid index */        static indexType maxValid;    public:        /** the pool referenced by this index */        indexType pool;        /** check the validity of the index */        bool valid() const;    };    /** descriptor header for buffers */    struct Header {        /** index of the allocating pool */        Index index;    };    /** query the size managed by a pool */    static uint getSize(const Index& index);    /** extract the size of a buffer */    static uint getSize(void* buffer);    /** query the amount of memory currently used by allocated buffers */    static size_t getUsedMemory();    /** initialize the buffer pool with buffer sizes to manage */    static mgi_error_t init(const PoolDescVec& poolDescs);    /** select a pool given a desired buffer size */    static Index select(uint size);    /** select the biggest pool available */    static Index selectMax();    /** grab a buffer from the pool (blocks until successful) */    static void* grab(const Index& index, const char *file, int line, uint retries = DEFAULT_POOL_RETRIES);    /** attempt to grab a buffer from the pool (non-blocking, NULL on failure) */    static void* tryGrab(const Index& index);    /** release a buffer back to the pool */    static void release(void* buffer);    /** garbage collector: runs at specified intervals of time (seconds) and        deallocates buffers from pools for which there is buffer availability        consistently across the history window.        IMPORTANT: the BufferPool must have been initialized before this is run*/    static void runGarbageCollector(double interval, uint windowSize);    /** make sure to properly free all the managed memory */    static void shutdown();};/** structure used to launch the garbage collector using the boost:thread lib.    \note: the buffer pool is a static component, and so only one collector thread           should ever be started. */struct BufferPoolGarbageCollector {    /** the time interval (in seconds) the collector runs (make > 1sec) */    double interval;    /** the size of the window for the availability history */    uint windowSize;    /** boost runs thread "mains" through this operator */    void operator()();};END_CRUSTA#endif //_BufferPool_H_